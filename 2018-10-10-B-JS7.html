<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>葡萄藤PPT</title>

    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/lib/reveal/css/zenburn.css">

    <style>
        .left {
            text-align: left;
        }
        ul {
            text-align: left;
        }
        p {
            text-align: left;
        }
    </style>



    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'https://ptteng.github.io/PPT/css/reveal/print/pdf.css' : 'https://ptteng.github.io/PPT/css/reveal/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<img src="./葡萄藤PPT_files/logo.png" alt="" usemap="#pttmap" class="base-logo">
<map name="pttmap">
    <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com/" alt="" target="_blank">
</map>
<div class="reveal default center" role="application" data-transition-speed="slow" data-background-transition="fade">
    <div class="slides"
         style="width: 960px; height: 700px; left: 50%; top: 50%; bottom: auto; right: auto; transform: translate(-50%, -50%) scale(0.756);">
        <section class="past" style="top: 158px; display: none;" hidden="" aria-hidden="true">
            <h2>【JS-task7】</h2>
            <h3>angular js中的依赖注入是什么？有什么作用？与不用依赖注入的其他框架相比，有何优点？
            </h3>
            <p>分享人:钟华俊</p>
        </section>
        <section class="past" style="top: 3px; display: block;" hidden="" aria-hidden="true">
        <p>目录</p>
            <p>1.背景介绍</p>
            <p>2.知识剖析</p>
            <p>3.常见问题</p>
            <p>4.解决方案</p>
            <p>5.编码实战</p>
            <p>6.扩展思考</p>
            <p>7.参考文献</p>
            <p>8.更多讨论</p>
        </section>
        <section>
            <h3>1.背景介绍</h3>
        </section>
        <section>
            <p class="left">依赖注入（Dependency Injection，简称DI）是一种软件设计模式，在这种模式下，一个或更多的依赖
                （或服务）被注入（或者通过引用传递）到一个独立的对象（或客户端）中，然后成为了该客户端状态的一部分。该模
                式分离了客户端依赖本身行为的创建，这使得程序设计变得松耦合，并遵循了依赖反转和单一职责原则。与服务定位器
                模式形成直接对比的是，它允许客户端了解客户端如何使用该系统找到依赖。

            </p>
        </section>

        <section>
            <p class="left">依赖注入产生的背景：传统应用程序通常是在类内部执行代码中主动创建这个类所依赖的其它对象， 从而
                导致类与类之间发生紧密耦合，使得类难于测试和隔离，最终导致系统的扩展和维护异常困难。

            </p>
        </section>

        <section>
            <p class="left">依赖注入用来解决组件之间依赖关系、配置及生命周期管理， 通过转移对象控制权，可以解决类之间的耦
                合问题， 对象与对象之间是松散耦合关系，更重要的是使得应用程序体系结构变得非常灵活， 很好的体现了面向对象的
                设计法则之一---依赖设计原则

            </p>
        </section>




        <section>
            <h3>2.知识剖析</h3>
        </section>
        <section>
            <h4></h4>
            <p class="left">依赖注入的原理：程序运行过程中，如需另一个对象协作(调用它的方法、访问他的属性)时，无须在代码
                中创建被调用者，而是依赖于外部容器的注入， 调用者仅通过声明某个组件就可以获得组件的控制权，而对该组件的依赖
                关系管理、查找、加载由外部完成。
            </p>

        </section>

        <section>
            <h4>在Angular中，依赖注入可谓无孔不入。通常在两种场景下会使用到依赖注入：</h4>
            <p class="left">

                1．工厂方法定义的组件（components）：如directive，factory，filter，provider，controller等。
                这些工厂函数需要注册到某个模块上。controller比较特殊，它虽然也是一种组件，但是特别之处是它与某个DOM元素关联
                ，因此可以注入$scope service，而其他组件只能注入$rootScope service。所有的供应商都只被实例化一次，也就说他
                们都是单例的，除了constant，所有的供应商都可以被装饰器(decorator)装饰，value就是一个简单的可注入的值，
                service是一个可注入的构造器，factory是一个可注入的方法，decorator可以修改或封装其他的供应商，当然除了constant
                ，provider是一个可配置的factory。

            </p>
        </section>

        <section>
            <h4>2.模块提供的run/config方法。</h4>
            <p class="left">Angular在加载模块时经过两个阶段：config和run。传入config函数的方法会在当前模块加载时执行；传入
                run函数的方法会在所有模块加载结束后执行。因此，在config阶段即可配置多个provider，但是在config阶段，只有provider
                可以注入，因此自定义的service无法注入到config中，config阶段是对service进行配置的而不是使用service本身。
                $provide service本身就是一个provider（对于Angular应用来讲相当于一个'元provider'），在模块加载时会调用$provide
                的provider方法定义一个新的provider。

            </p>

        </section>





        <section>
            <h3>3.常见问题</h3>
        </section>
        <section>
            <p> 依赖注入有几种方法</p>
            <p>如何使用这几种依赖注入的方法</p>
        </section>

        <section>

            <h3>4.解决方案</h3>
        </section>
        <section>
            <h4> 依赖注入有几种方法</h4>
            <p>依赖注解有三种方式，（数组标注、添加$inject属性、隐式声明）。

                其中前两种在代码minify时不会被破坏，推荐使用第一种方式。

                第三种方式，书写最为简单明了，但是不能对它直接进行minify，需要改写为前两种。
            </p>
        </section>
        <section>
            <h4>如何使用这几种依赖注入的方法</h4>
            <p> 1、数组标注

                someModule.controller('MyController', ['$scope', 'greeter', function($scope, greeter) {

                }]);
            </p>
            <p> js压缩混淆不会有影响，优先考虑用该方式为组件定义依赖。在代码中通过在第二个数组类型的参数中声明了'$scope',
                'greeter'等依赖，数组最后一个元素为实际的构造方法，注意在构造方法的参数列表与其面的数组元素是一一对应的。
            </p>
        </section>
        <section>
            <p>  2、显式注入声明（$inject属性）

                var MyController = function($scope, greeter) {

                }

                MyController.$inject = ['$scope', 'greeter'];

                someModule.controller('MyController', MyController);
            </p>
            <p> AngularJS提供了显式的方法来明确定义一个函数在被调用时需要用到的依赖关系。通过这种方法声明依赖，即使在源代
                码被压缩、参数名称发生改变的情况下依然能够正常工作。我们给我们的函数设置的参数名称分别是$scope和greeter，
                然后我们在后面使用MyController.$inject=['$scope','greeter'];显式的将我们需要的依赖注入到MyController函数中；

            </p>
        </section>
        <section>
            <p>    3、隐式声明依赖

                someModule.controller('MyController', function($scope, greeter) {

                });
            </p>
            <p>最简单的声明依赖的方式就是让设构造方法的参数与依赖的名字一样。如果没有明确的声明，AngularJS会假定参数名称
                就是依赖的名称。请注意，这个过程只适用于未经过压缩和混淆的代码，因为AngularJS需要原始未经压缩的参数列表
                来进行解析当AngularJS实例化这个模块时，会查找greeter并自然而然地把对它的引用传递进去这里我们先看一个简单的依赖注入的例子。

            </p>
        </section>




        <section>
            <h3>5.编码实战</h3>
        </section>

        <section>
            <h3>6.扩展思考</h3>
        </section>
        <section>
            <h4>AngularJS中的依赖注入与不用依赖注入的其他框架相比，有何优点？</h4>
            <p>1. 模板功能强大丰富，并且是声明式的，自带了丰富的Angular指令；</p>

            <p> 2. 是一个比较完善的前端MVC框架，包含模板，数据双向绑定，路由，模块化，服务，过滤器，依赖注入等所有功能；

             </p>

        </section>

        <section>
            <p>
            3. 依赖注入简化了组件之间处理依赖的过程（即解决依赖）。没有依赖注入，就不得不以某种方式自己查找$scope，很可能
            得使用全局变量。这虽然能够工作，但是不如AngularJS的依赖注入技术这么简单。
            </p>
            <p> 4. 在开发中使用依赖注入的主要好处是AngularJS负责管理组件并在需要的时候提供给相应函数。依赖注入还能够为测试带
            来好处，因为它允许你使用假的或者模拟的对象来代替真实的组件，从而让开发者专注于程序的特定部分。
            </p>
        </section>



        <section>
            <h3>7.参考文献</h3>
            <p>参考资料：http://www.html-js.com/article/1980</p>
            <p>——  理解AngularJS中的依赖注入</p>
            <p>参考资料：https://blog.csdn.net/luo_xinran/article/details/52153830</p>
            <p>—— AngularJS基础 之 依赖注入的几种方法</p>
        </section>

        <section>
            <h3>8.更多讨论</h3>
            <p> 上面说的这些依赖组件的本质是什么？</p>
            <p> factory和value等服务与provider都是提供服务，为什么还要使用provider?</p>
            <p> 什么时候适合使用service方法？</p>
        </section>

        <section>
            <p>鸣谢</p>
            <p>感谢大家观看</p>
            <p><small>BY : 钟华俊</small></p>
        </section>

    </div>
</div>

<script src="https://ptteng.github.io/PPT/lib/reveal/js/head.min.js"></script>
<script src="https://ptteng.github.io/PPT/lib/reveal/reveal.js"></script>

<script>
    // 以下为常见配置属性的默认值
    // {
    // 	controls: true, // 是否在右下角展示控制条
    // 	progress: true, // 是否显示演示的进度条
    // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
    // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
    // 	keyboard: true, // 是否启用键盘快捷键来导航
    // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
    // 	center: true, // 是否将幻灯片垂直居中
    // 	touch: true, // 是否在触屏设备上启用触摸滑动切换
    // 	loop: false, // 是否循环演示
    // 	rtl: false, // 是否将演示的方向变成RTL，即从右往左
    // 	fragments: true, // 全局开启和关闭碎片。
    // 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
    // 	transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
    // 	transitionSpeed: 'default', // 过渡速度，default/fast/slow
    // 	mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
    // }
    // 初始化幻灯片
    Reveal.initialize({
//        history: true,
        transition: 'default',
        transitionSpeed: 'slow',
        dependencies: [
            {src: '../plugin/markdown/marked.js'},
            {src: '../plugin/markdown/markdown.js'},
            {src: '../plugin/notes/notes.js', async: true},
            {
                src: '../plugin/highlight/highlight.js', async: true, callback: function () {
                    hljs.initHighlightingOnLoad();
                }
            }
        ]
    });
</script>
</body>
</html>
Contact GitHub API Training Shop Blog About
© 2016 GitHub, Inc. Terms Privacy Security Status He



